#!/bin/bash

# This is a very hackerish proof of concept of
# a helper tool to manage software issues
# directly within git commits.

########
# check if given issue commit id is valid, return last issue if none given
########
issueid=
get_issueid()
{
	if [ -n "$1" ]
	then
		issueid=`git rev-list --all --abbrev-commit -n1 --grep "^issue: " "$1"`
		if [ -z "$issueid" ]
		then
			echo "$1 is not an issue commit"
			exit 1
		fi
	else
		issueid=`git rev-list --all  --abbrev-commit -n1 --grep "^issue: "`
		if [ -z "$issueid" ]
		then
			echo "no issues found"
			exit 1
		fi
	fi
}

########
# create a new issue, committing working tree if touched
########
new ()
{
	git commit --allow-empty -em "issue:

issue-status: open
# open, fixed, wontfix, invalid
issue-type: bug
# bug, feature, security
#issue-keyword:
#issue-affected:
#issue-redmine:
# refs #x, fixes #y
" $@
	exit $?
}

########
# update a given issue, committing working tree if touched
########
update ()
{
	get_issueid $1
	shift
	git commit --allow-empty -em "#title

issue-id: $issueid
issue-status: fixed
# open, fixed, wontfix, invalid
#issue-redmine:
# refs #x, fixes #y
" "$@"
	exit $?
}

########
# show issue opening and associated commits
########
show ()
{
	get_issueid "$1"
	git show -s $issueid
	echo ""
	git log --all --grep "^issue-id: $issueid" --reverse
	exit $?
}

########
# get the status of an issue in a given revision
########
revstatus=
get_revstatus ()
{
	issue=$1
	rev=$2
	# check if opened at given revision
	revs=`git rev-list "$rev" | grep "^$issue"`
	if [ -n "$revs" ]
	then
		revstatus=`git show -s --format=format:%b "$issue" | \
			grep "^issue-status: " | awk '{print \$2}'`
		for commit in `git rev-list --reverse --abbrev-commit --all-match  \
						--grep "^issue-id: $issue" --grep "^issue-status: " $rev`
		do
			revstatus=`git show -s --format=format:%b $commit | \
				grep "^issue-status: " | awk '{print \$2}'`
		done

		# no status given? assume open
		if [ -z "$revstatus" ]
		then
			revstatus="open"
		fi
	else
		# issue is not known in this revision, assume open
		# TODO: check for issue-affected: use invalid if $rev older
		revstatus="open"
	fi
}

########
# get the type of the issue
########
issuetype=
get_issuetype ()
{
	issue=$1
	issuetype=`git show -s --format=format:%b "$issue" | \
				grep "^issue-type: " | awk '{print \$2}'`
	for commit in `git rev-list --all --all-match  \
					--grep "^issue-id: $issue " --grep "^issue-status: " $rev`
	do
		issuetype=`git show -s --format=format:%b $commit | \
					grep "^issue-status: " | awk '{print \$2}'`
	done

	if [ -z "$issuetype" ]
	then
		revstatus="unknown"
	fi
}

########
# print a one line status of a single issue
########
status ()
{
	issue=$1
	revision=$2
	if [ -z $revision ]
	then
		revision="HEAD"
	fi
	subj=`git show $issue -s --format=format:%s`
	get_revstatus $issue $revision
	get_issuetype $issue
	echo "$issue ($issuetype, $revstatus): ${subj:7}"
}

########
# show info about a single issue
########
info ()
{
	get_issueid $1
	status $issueid $2
	exit 0
}

########
# list all issues for a given revision
########
list ()
{
	for issue in `git rev-list --all --abbrev-commit --grep "^issue: "`
	do
		status $issue "$@"
	done
	exit 0
}

########
# show usage summary
########
usage ()
{
	echo "usage: $0 <command>
  new       create a new issue, using working tree as commit
  update    update an issue, using working tree as commit
            if no issue commit id is given, last issue is used
  list      list all known issues with status
            argument is revision to check issue status against, defaults to HEAD
  info      show status of an issue given as first argument
            if no issue commit id is given, last issue is used
            second argument is revision to check issue status against
  show      show commits related to an issue
            if no issue commit id is given, last issue is used
  help      show this help"
	exit 0
}

if [ -z $1 ]
then
	usage
fi

command=$1
shift

case "$command" in
	new)
		new "$@"
		;;
	update)
		update "$@"
		;;
	list)
		list "$@"
		;;
	info)
		info "$@"
		;;
	show)
		show "$@"
		;;
	help)
		usage
		;;
esac

echo "invalid command: $command"
exit 1
