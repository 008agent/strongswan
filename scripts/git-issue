#!/bin/bash

# This is a very hackerish proof of concept of
# a helper tool to manage software issues
# directly within git commits.

########
# check if given issue commit id is valid, return last issue if none given
########
issueid=
get_issueid()
{
	if [ -n "$1" ]
	then
		issueid=$(git show -s --grep "^issue: " --format=format:%h $1)
		if [ -z "$issueid" ]
		then
			echo "$1 is not an issue commit"
			exit 1
		fi
	else
		issueid=$(git rev-list --all --abbrev-commit -n1 --grep "^issue: ")
		if [ -z "$issueid" ]
		then
			echo "no issues found"
			exit 1
		fi
	fi
}

########
# create a new issue, committing working tree if touched
########
new ()
{
	git commit --allow-empty -em "issue:

issue-status: open
# open, fixed, wontfix, invalid
issue-type: bug
# bug, feature, security
#issue-keyword:
#issue-affected:
#issue-redmine:
# refs #x, fixes #y
" $@
	exit $?
}

########
# update a given issue, committing working tree if touched
########
update ()
{
	get_issueid $1
	shift
	git commit --allow-empty -em "#title

issue-id: $issueid
issue-status: fixed
# open, fixed, wontfix, invalid
#issue-redmine:
# refs #x, fixes #y
" "$@"
	exit $?
}

########
# show issue opening and associated commits
########
show ()
{
	get_issueid "$1"
	git show -s $issueid
	echo ""
	git log --all --grep "^issue-id: $issueid" --reverse
	exit $?
}

########
# get the status of an issue in a given revision
########
revstatus=
get_revstatus ()
{
	local stat
	local aff
	local fixed
	local issue=$1
	local rev=$2

	# check for issue-fixed: keyword first
	for update in $(git rev-list -n1 --all-match $rev \
					--grep "^issue-id: $issue" --grep "^issue-fixed: ")
	do
		issue="$update"
	done

	fixed=$(git show -s --format=format:%b $issue | grep "^issue-fixed: ")
	for fix in ${fixed:13}
	do
		# it has been fixed, check if that fix is in target revision
		fix=$(git rev-list "$rev" | grep "^$fix")
		if [ -n "$fix" ]
		then
			revstatus="fixed"
			return
		fi
	done

	# check if opened at given revision
	issue=$1
	local revs=$(git rev-list "$rev" | grep "^$issue")
	if [ -n "$revs" ]
	then
		# use status of last issue update, if any
		for update in $(git rev-list -n1 --all-match $rev \
						--grep "^issue-id: $issue" --grep "^issue-status: ")
		do
			issue="$update"
		done

		stat=$(git show -s --format=format:%b $issue | grep "^issue-status: ")

		# no status found? assume open
		if [ -z "$stat" ]
		then
			revstatus="open"
		else
			revstatus=${stat:14}
		fi
	else
		# issue is not known in this revision, assume open, unless affected

		for update in $(git rev-list -n1 --all --all-match \
						--grep "^issue-id: $issue" --grep "^issue-affected: ")
		do
			issue="$update"
		done

		aff=$(git show -s --format=format:%b $issue | grep "^issue-affected: ")

		if [ -n "$aff" ]
		then
			aff=${aff:16}
			# resolve commit id if affected by tag
			aff=$(git show -s $aff^{commit} --format=format:%h)
			revstatus=$(git rev-list "$rev" | grep "^$aff")
			if [ -n "$revstatus" ]
			then
				# in affected range, must be open
				revstatus="open"
			else
				# not in affected range,  unaffected
				revstatus="unaffected"
			fi
		else
			# no affected info found, assume open
			revstatus="open"
		fi
	fi
}

########
# get the type of the issue
########
issuetype=
get_issuetype ()
{
	local type
	local issue=$1

	# use status of last type update, if any
	for update in $(git rev-list -n1 --all --all-match \
					--grep "^issue-id: $issue " --grep "^issue-type: ")
	do
		issue="$update"
	done

	type=$(git show -s --format=format:%b $issue | grep "^issue-type: ")

	if [ -n "$type" ]
	then
		issuetype=${type:12}
	else
		issuetype="unknown"
	fi
}

########
# print a one line status of a single issue
########
status ()
{
	local subj
	local issue=$1
	local revision=$2
	if [ -z $revision ]
	then
		revision="HEAD"
	fi
	subj=$(git show $issue -s --format=format:%s)
	get_revstatus $issue $revision
	get_issuetype $issue
	echo "$issue ($issuetype, $revstatus): ${subj:7}"
}

########
# show info about a single issue
########
info ()
{
	get_issueid $1
	status $issueid $2
	exit 0
}

########
# list all issues for a given revision
########
list ()
{
	for issue in $(git rev-list --all --abbrev-commit --grep "^issue: ")
	do
		status $issue "$@"
	done
	exit 0
}

########
# show usage summary
########
usage ()
{
	echo "usage: $0 <command>
  new       create a new issue, using working tree as commit
  update    update an issue, using working tree as commit
            if no issue commit id is given, last issue is used
  list      list all known issues with status
            argument is revision to check issue status against, defaults to HEAD
  info      show status of an issue given as first argument
            if no issue commit id is given, last issue is used
            second argument is revision to check issue status against
  show      show commits related to an issue
            if no issue commit id is given, last issue is used
  help      show this help"
	exit 0
}

if [ -z $1 ]
then
	usage
fi

command=$1
shift

case "$command" in
	new)
		new "$@"
		;;
	update)
		update "$@"
		;;
	list)
		list "$@"
		;;
	info)
		info "$@"
		;;
	show)
		show "$@"
		;;
	help)
		usage
		;;
esac

echo "invalid command: $command"
exit 1
